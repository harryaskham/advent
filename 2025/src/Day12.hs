module Day12 where

part1' :: ℤ
part1' =
  let (ps, rs) :: [(ℤ, ".#" ▦ ℤ²)] × [(ℤ², [ℤ])] = ($(aoc 12) & (⊏|⊐) @(([(ℤ, ".#" ▦ ℤ²) ⯻ ":\n"] ≠ []) × ([(ℤ² ⯻ "x", [ℤ] ⯻ " ") ⯻ ": "] ≠ [])))
      vs :: [[Set ℤ²]] = uniq ∘ (((⌞) ∘) <$> ((∘) <$> [id, (↻), ((↻)) ∘ ((↻)), ((↺))] <*> [id, ((◓)), ((◐))]) <*>) ∘ φ ∘ ͼ ∘ (|?> (#"#" □)) ∘ snd <$> ps
      go Φ = False
      go ((((w, h), ns), ((x, y), s)) :<!! q) =
        all (≡ 0) ns
          ∨ (ⵉ ((((|.|) ∘ (⟒)) <$> vs, ns) ⤊ (⋅)) |≤| s)
          ∧ (go (((\((_, ns), (_, s)) -> (ⵉ (ns <&> (^ 2)), -(s |.|))), [(((w, h), ns'), (x ∈ (0 ⥅ w - 3) ??? (x + 1, y) $ (0, y + 1), s')) | (ns', s') <- (ns, s) : [(ns !. (i, n - 1), s ∖ v) | (i, n) <- (ns ..#), n > 0, v <- vs !! i <&> (⇆⇅ (x, y)), v ∩ s ≡ v]]) ||-> q))
          ∨ go q
   in rs |?| (go ∘ mkℤ₁ ∘ (⇲ (((0, 0),) ∘ box₀ @Set ∘ fst)) ∘ dup)

part1 =
  let (ps, rs) :: [(ℤ, ".#" ▦ ℤ²)] × [(ℤ², [ℤ])] = $(aoc 12) & (⊏|⊐) @(([(ℤ, ".#" ▦ ℤ²) ⯻ ":\n"] ≠ []) × ([(ℤ² ⯻ "x", [ℤ] ⯻ " ") ⯻ ": "] ≠ []))
   in rs |?| \((w, h), ns) -> ⵉ [n ⋅ (ͽ p |.|) | ((_, p), n) <- ps ⇑ ns] ≤ w ⋅ h
